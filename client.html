<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MurmuresJS</title>
    <link rel="stylesheet" href="src/css/client.css" media="screen">
</head>
<body onload="init()">
    <div style="position:fixed; bottom:0; left:0; z-index:9999">
        <div id="debugDiv"></div>
    </div>
    <script type="text/javascript">
        'use strict';
        // namespace
        var murmures = {}; 
    </script>
    <script src="src/character.js"></script>
    <script src="src/level.js"></script>
    <script src="src/order.js"></script>
    <script src="src/tile.js"></script>
    <script src="src/gameEngine.js"></script>

    <script type="text/javascript">
        'use strict';
        var gameEngine = new murmures.gameEngine();

        // #region Utils
        function screenLog(txt) {
            let now = new Date();
            document.getElementById("screenLog").insertAdjacentHTML('afterbegin', '<span style="color:#ffa">' + now.toLocaleTimeString() + '.' + ('00' + now.getMilliseconds().toString()).substr(-3) + '</span> ' + txt + '<br/>');
        }

        function sendAjax(path, param, callback, async) {
            let xhr = new XMLHttpRequest();
            xhr.onerror = onXhrError;
            xhr.open('POST', window.location.href + path, async);
            xhr.setRequestHeader('Content-Type', 'application/json');
            if (callback !== null) {
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        callback(xhr.responseText);
                    }
                };                
            }
            xhr.send(param);
        }

        function onXhrError(e) {
            alert('Vous avez été déconnecté du serveur');
        }
        // #endregion

        function init() {
            screenLog('>> getLevel');
            sendAjax('getLevel', '{"id":"level1"}', loadEngine, true);
            registerEvents();
        }


        // #region Renderer
        function renderLevel() {
            let allCanvas = document.getElementsByTagName("canvas");
            for (let canvasIter = 0; canvasIter < allCanvas.length; canvasIter++) {
                allCanvas[canvasIter].width = 1 + gameEngine.level.width * gameEngine.tileSize; // This is a hard reset of all canvas and is quite time consumming.
                allCanvas[canvasIter].height = 1 + gameEngine.level.height * gameEngine.tileSize;
                let context = allCanvas[canvasIter].getContext('2d');
                context.translate(0.5, 0.5); // translation prevents anti-aliasing.
            }
            drawGrid();
            drawTiles();
            initUI();
            updateCharacters();
        }

        // #region Grid
        function drawGrid() {
            let layer = document.getElementById('gridLayer');
            let context = layer.getContext('2d');
            context.clearRect(-0.5, -0.5, layer.width, layer.height);
            for (let x = 0; x < gameEngine.level.width; x++) {
                for (let y = 0; y < gameEngine.level.height; y++) {
                    drawOneSquare(context, x, y, "#ccc", false); // light gray
                }
            }
        }

        function drawOneSquare(context, x, y, color, filled) {
            context.beginPath();
            if (filled || y === 0) {
                context.moveTo(gameEngine.tileSize * x, gameEngine.tileSize * y);
                context.lineTo(gameEngine.tileSize * x + gameEngine.tileSize, gameEngine.tileSize * y);
            }
            else {
                context.moveTo(gameEngine.tileSize * x + gameEngine.tileSize, gameEngine.tileSize * y);
            }
            context.lineTo(gameEngine.tileSize * x + gameEngine.tileSize, gameEngine.tileSize * y + gameEngine.tileSize);
            context.lineTo(gameEngine.tileSize * x, gameEngine.tileSize * y + gameEngine.tileSize);
            if (filled || x === 0) {
                context.lineTo(gameEngine.tileSize * x, gameEngine.tileSize * y);
            }
            context.strokeStyle = color;
            context.stroke();
            if (filled) {
                context.closePath();
                context.fillStyle = color;
                context.fill();
            }
        }
        // #endregion

        // #region Tiles
        function drawTiles() {
            let layer = document.getElementById('tilesLayer');
            let context = layer.getContext('2d');
            context.clearRect(-0.5, -0.5, layer.width, layer.height);
            for (let x = 0; x < gameEngine.level.width; x++) {
                for (let y = 0; y < gameEngine.level.height; y++) {
                    drawOneTile(context, x, y, "#2D1E19");
                }
            }
        }

        function drawOneTile(context, x, y, color) {
            if ((x === 0) || (y === 0) || (x === gameEngine.level.width - 1) || (y === gameEngine.level.height - 1)) {
                drawOneSquare(context, x, y, color, true);
            }
            else {
              
                if (gameEngine.level.tiles[y][x].content === 1) {
                    console.log(gameEngine.level.tiles[y][x]);
                    if (gameEngine.level.tiles[y][x].state == 0){
                      drawOneSquare(context, x, y, "#000000", true);
                    }else{
                      drawOneSquare(context, x, y, color, true);
                     }
                }
            }
        }
        // #endregion

        // #region Characters
        function initUI() {
            let characterUiTemplate = document.getElementById('characterUiTemplate').innerHTML;
            let templateStr = /template/g;
            document.getElementById('rightCharacters').innerHTML += characterUiTemplate.replace(templateStr, 'mob0');
            document.getElementById('rightCharacters').innerHTML += characterUiTemplate.replace(templateStr, 'mob1');
            document.getElementById('leftCharacters').innerHTML += characterUiTemplate.replace(templateStr, 'hero0').replace('bgColorMob', 'bgColorHero');
        }

        function updateCharacters() {
            clearCharacterLayer();
            for (let i = 0; i < gameEngine.mobs.length; i++) {
                document.getElementById('mob' + i + '-icon').src = gameEngine.mobs[i].img;
                document.getElementById('mob' + i + '-name').innerHTML = 'Squelette';
                let missingLife = parseFloat(gameEngine.mobs[i].hitPoints) / parseFloat(gameEngine.mobs[i].hitPointsMax) * 100.0;
                document.getElementById('mob' + i + '-life').style.width = Math.round(missingLife).toString() + '%';
                if (gameEngine.mobs[i].hitPoints === 0) {
                    document.getElementById('mob' + i + '-box').style.display = "none";
                }
                else {
                    drawCharacter(gameEngine.mobs[i]);
                }
            }
            let i = 0;
            document.getElementById('hero' + i + '-icon').src = gameEngine.hero.img;
            document.getElementById('hero' + i + '-name').innerHTML = gameEngine.hero.name;
            let missingLife = parseFloat(gameEngine.hero.hitPoints) / parseFloat(gameEngine.hero.hitPointsMax) * 100.0;
            document.getElementById('hero' + i + '-life').style.width = Math.round(missingLife).toString() + '%';
            drawCharacter(gameEngine.hero);
        }

        function clearCharacterLayer() {
            let layer = document.getElementById('characterLayer');
            let context = layer.getContext('2d');
            context.clearRect(-0.5, -0.5, layer.width, layer.height);
            context.imageSmoothingEnabled = false;
        }

        function drawCharacter(character) {
            /// <param name="character" type="character"/>
            let layer = document.getElementById('characterLayer');
            let context = layer.getContext('2d');
            let img = new Image();
            img.onload = function () {
                context.drawImage(img, character.position.x * gameEngine.tileSize, character.position.y * gameEngine.tileSize, gameEngine.tileSize, gameEngine.tileSize);
            };
            img.src = character.img;
        }
        // #endregion
        // #endregion

        function loadEngine(engine) {
            screenLog('<< loadEngine');
            gameEngine.fromJson(JSON.parse(engine));
            renderLevel();
        }

        function registerEvents() {
            // IE11 returns decimal number for MouseEvent coordinates but Chrome43 always rounds down.
            // --> using floor() for consistency.
            // Also, rounding cancels the canvas shift (0.5 pixel)
            // and retrieves the nearest pixel coordinates.
            let topLayer = document.getElementById("topLayer");
            topLayer.addEventListener("mousedown", function (e) {
                e.preventDefault(); // usually, keeping the left mouse button down triggers a text selection or a drag & drop.
                let mouseX = Math.floor(e.offsetX);
                let mouseY = Math.floor(e.offsetY);
                topLayer_onClick(mouseX, mouseY, e.button == 2);
            }, false);
            window.addEventListener("keypress", function (e) {
                let char = '';
                if (e.which == null)
                    char = String.fromCharCode(e.keyCode);
                else
                    char = String.fromCharCode(e.which);
                onKeyPress(char);
            }, false);
        }

        function topLayer_onClick(mouseEventX, mouseEventY, rightClick) {
            if (!rightClick) {
                // event is a left click
                // find hovered tile
                let hoveredTile = getHoveredTile(mouseEventX, mouseEventY);
                if (gameEngine.tileHasMob(hoveredTile)) {
                    let attackOrder = new murmures.order();
                    attackOrder.command = "attack";
                    attackOrder.source = gameEngine.hero;
                    attackOrder.target = hoveredTile;
                    launchOrder(attackOrder);
                }
                else {
                    let moveOrder = new murmures.order();
                    moveOrder.command = "move";
                    moveOrder.source = gameEngine.hero;
                    moveOrder.target = hoveredTile;
                    launchOrder(moveOrder);
                }
            }
            else {
                // event is a right click
                let hoveredTile = getHoveredTile(mouseEventX, mouseEventY);
            }
        }

        function getHoveredTile(mouseEventX, mouseEventY) {
            let tileX = Math.floor(mouseEventX / gameEngine.tileSize);
            let tileY = Math.floor(mouseEventY / gameEngine.tileSize);
            document.getElementById('debugDiv').innerHTML = ''.concat(tileX, ' ', tileY);
            let ret = new murmures.tile();
            ret.x = tileX;
            ret.y = tileY;
            return ret;
        }

        function onKeyPress(char) {
            let allowedChars = '12346789';
            if (allowedChars.indexOf(char) >= 0) {
                let moveOrder = new murmures.order();
                moveOrder.command = "move";
                moveOrder.source = gameEngine.hero;
                let target = new murmures.tile();
                if (char === '9' || char === '6' || char === '3') target.x = gameEngine.hero.position.x + 1;
                if (char === '7' || char === '4' || char === '1') target.x = gameEngine.hero.position.x - 1;
                if (char === '8' || char === '2') target.x = gameEngine.hero.position.x;
                if (char === '9' || char === '8' || char === '7') target.y = gameEngine.hero.position.y - 1;
                if (char === '3' || char === '2' || char === '1') target.y = gameEngine.hero.position.y + 1;
                if (char === '4' || char === '6') target.y = gameEngine.hero.position.y;
                moveOrder.target = target;
                launchOrder(moveOrder);
            }
            else {
                screenLog('<span style="color:#f66">' + 'ERROR - This is not a valid key</span>');
            }
        }

        function launchOrder(order) {
            let check = gameEngine.checkOrder(order);
            if (check.valid) {
                screenLog('>> order - ' + order.command);
                sendAjax('order', JSON.stringify(order), onOrderResponse, true);
            }
            else {
                screenLog('<span style="color:#f66">' + 'ERROR - Invalid order - ' + check.reason + '</span>');
            }
        }

        function onOrderResponse(response) {
            screenLog('<< onOrderResponse');
            let ge = JSON.parse(response);
            gameEngine.hero = ge.hero;
            gameEngine.mobs = ge.mobs;
            updateCharacters();
        }


    </script>
    <script type="text/html" id="characterUiTemplate">
        <div id="template-box" class="characterBox bgColorMob">
            <div>
                <div>
                    <img id="template-icon" class="uiIcon" src=".">
                </div>
                <div class="characterName">
                    <div id="template-name">Chauve-souris</div>
                </div>
                <div class="newLine characterLife">
                    <div id="template-life"></div>
                </div>
                <div class="newLine uiIcon"></div>
                <div class="uiIcon"></div>
                <div class="uiIcon"></div>
                <div class="uiIcon"></div>
                <div class="newLine uiIcon"></div>
                <div class="uiIcon"></div>
                <div class="uiIcon"></div>
                <div class="uiIcon"></div>
            </div>
        </div>
    </script>
    <!--
    <div id="fullScreen" style="position:absolute; top:0; left:0; width:100%; height:100%; background-color:#f8f8f8; z-index:-20"></div>
    <div id="iPhone6" style="position:absolute; top:0; left:0; width:1334px; height:750px; background-color:#f8fff8; z-index:-10"></div>
    <div id="iPhone5" style="position:absolute; top:0; left:0; width:1136px; height:640px; background-color:#f8f8ff; z-index:-9"></div>
    <div id="iPhone4" style="position:absolute; top:0; left:0; width:960px; height:640px; background-color:#fff8f8; z-index:-8"></div>
    <div id="galaxyS3Mini" style="position:absolute; top:0; left:0; width:800px; height:480px; background-color:#fff; z-index:-7"></div>
    -->
    <div id="targetResolution" class="fullScreen">
        <div id="rightCharacters" class="zUI" style="float:right">
        </div>
        <div id="leftCharacters" class="zUI" style="float:left">
        </div>
    </div>

    <button type="button" onclick="init()" style="display:none">Get level</button>

    <div style="float:left; position:relative;">
        <canvas id="topLayer" width="1400" height="840" style="z-index: 99"></canvas>
        <canvas id="characterLayer" width="1400" height="840" style="z-index: 30"></canvas>
        <canvas id="gridLayer" width="1400" height="840" style="z-index: 25; opacity:0.2"></canvas>
        <canvas id="tilesLayer" width="1400" height="840" style="z-index: 15"></canvas>
        <code id="screenLog" style="position:relative; top:400px; margin:2px 7px; width:636px; height:300px; z-index:9999; color:white; overflow:auto; display: block;"></code>
    </div>


</body>
</html>
